---
tags: AtCoder いつか解く600点リスト
---
## 全体の感想
約 1 時間で A ~ D の 4 完

E の実装に取り掛かっている段階でコンテスト終了。
コンテスト終了後 20 分ほどで AC できた。
D の速解きでこの時間を捻出したいね。

F は 500 点だったのですぐ解説を読んでしまったが、自力で解ける難易度感に思えた。
こういうので配列をソートしておくのは典型だよね。（それすら考えずに解説を読んでしまった。）

G はノータッチ。
高度な数学知識は要らないっぽいので、600 点に挑戦し始めるときが来たら戻ってこようかな。

---

## A

### 問題概要
文字を適切に replace する。

### 感想と解説
文字列をこねこねするのは C++ より Python の方が得意がち。
実際、Python の `str` に `replace` というメソッドがあるのだが、安易に
```python
D = input()
ans = D.replace('N', 'S').replace('E', 'W').replace('W', 'E').replace('S', 'N')
```
のように `replace` を繋げる方針は、N が S に置換され、その後に S が N に置換されるという流れで失敗してしまう。
ずばり `translate` メソッドの使い所なのだが、使い方がやや難しくてあんまり覚えていない。

前から 1 文字ずつ見て置換後の文字を求め、答えを構築する方針を思いついたので、そちらで解いた。
「Python の方が得意がち」とか言ったが C++ で実装した。
取り立てて C++ の方に強みがあったわけでもない。気まぐれ。

## B
### 問題概要
文字の二次元配列 S, T が与えられるので、S の中から T のパターンに一致する場所を探す。
そのような場所はちょうど 1 箇所だけ存在することが保証されている。

### 感想と解説
配列の大きさが小さいので全探索。
添字の繰り返し範囲に悩まされるが、問題文に書かれている式が参考になる。

（以下、添字は 0 始まりとする。）
まず、T の添字は `i`, `j` として、これの範囲は `0 <= i, j < M` 。
そして、S の添字は `a`, `b` として、これの範囲は、問題文に $1 <= a, b <= N-M+1$ とあるので `0 <= a, b < N-M+1` でいいか、となった。だめだったらそのとき考えればいい。
S と T の比較は `S[a+i][b+j] == T[i][j]` でいい。

## C
### 問題概要
N 匹の鳩と N 個の巣がある。
「P 番目の鳩が H 番目の巣に移動するので、移動後、2 匹以上の鳩がいる巣の個数を答える」クエリに Q 回対応する。

### 感想と解説
「i 番目の鳩がいる巣の番号」を記憶して、クエリごとに集計する方針では `TLE` してしまう。
集計結果を記憶し、結果だけ更新することで集計にかかる計算を削減できる。
集計結果の差分更新は「i 番目の巣にいる鳩の数」も分かればできる。

意味 | 変数名
--- | ---
i 番目の鳩がいる巣の番号 | pos
i 番目の巣にいる鳩の数 | cnt
集計結果 | ans

って公式解説のネーミングと完全一致してる競プロer多そう

## D
### 問題概要
横幅 W 列のテトリスっぽい盤面に N 個の正方形ブロックが存在する。
時刻 $t = 1, 2, 3, \dots$ ごとに以下のイベントが起こる。
* 最下層がブロックで埋まっているならば、それらを消す。
* 残っているブロックについて、重力にしたがって落下する。
「時刻 T のイベントが起こった後の状態で、A 番目のブロックは消えていないか？」というクエリに Q 回答える。

### 感想と解説
[いつぞやのF問題](https://atcoder.jp/contests/abc382/tasks/abc382_f) みたいに遅延セグ木で解くのかとビビった。ちなみに執筆時現在、まだ解いていない。
問題文を読み直すと、ブロックが正方形と分かり、助かった。

列ごとにブロックの位置と番号を記憶すれば、「次にいつ・どのブロックが消えるのか（あるいは、今後どのブロックも消えないのか）」を $O(W)$ で求められる。
クエリ処理前に、このシミュレーションで、各ブロックについて消える時刻を求めておく。消えないブロックについては、時刻 `inf` （十分大きい数）に消えるとみなす。
シミュレーションでは $O(W)$ の処理を繰り返すため、計算量がやや不安だったが、なんやかんやで $O(N)$ になる気がしたので、`TLE` をもらったらそのとき考えることにした。

`TLE` はしなかったが `WA` をもらった。
* 時刻 $t$ の更新間違い
* 次にブロックが消える時刻の計算間違い
* 最下層でないブロックを消している

などしていたので直す。なかなか難儀してしまった。

なお、 $i < j$ かつ $X_i = X_j$ ならば $Y_i < Y_j$（つまり、各列について下から順に入力される）という制約はないので、シミュレーション前に各列についてソートが必要なのだが、これを忘れても `AC` がもらえた。
コンテスト後の仲間内での感想戦で、友人に指摘されるまでまったく気づかなかった……
[提出コード](https://atcoder.jp/contests/abc391/submissions/62290479)
