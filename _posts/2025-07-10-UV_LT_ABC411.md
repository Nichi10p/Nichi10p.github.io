---
title: Python スクリプトで誤答ケースの発見を自動化
tags: LT
---

2025年7月9日（水）に開催されたユニークビジョン社での競プロLT会で登壇した資料を、ブログ記事向けに再編集しました。


# 概要

- テストケースの生成
- 生成したテストケースを利用してプログラムを実行
- 出力が AC か判定

を自動で繰り返すことで、WA の原因を考えるヒントとしたり、問題のサンプル入出力が弱い場合の補強としたりできます。\
入力データはランダム生成のほか、順列や組合せの列挙も活用するといいでしょう。

なお、Python コードの読み書きがある程度できることが前提となっています。


# 機能

## 動作環境

Windows, macOS, Linux いずれでも動作すると思います。

## サポートするジャッジ

- 通常ジャッジ
  - 正答が入力に対して一意に定まるような問題のジャッジ
  - 愚直解や他人のAC解を利用して、出力が一致しているかどうかで判定する
- スペシャルジャッジ
  - 正答が入力に対して複数存在しうるような問題のジャッジ
  - 入力データと出力データを読んで、出力データが条件を満たしているか確認するプログラムを書いて判定する
- インタラクティブ
  - コンテスタント側のプログラムとジャッジ側のプログラムが出力をやりとりして、規定のやりとりができたらAC
  - ジャッジ側のプログラムを書く

インタラクティブ形式に対応している点がアピールポイントです！


# スクリプト全体

不要な `import` がたくさんありますが、`generate` でよく使うやつをそのまま残しています。

自分でも使いたい、という方はちょっと面倒ですがコピペしてください。\
なお、再頒布などは想定していないのでライセンスは設定していません。All rights reserved です。（私的利用の範囲内なら複製は自由です）\
何か有用な改変があって、広めたいという場合は連絡ください。ライセンスはそのとき考えます。

その他、コードの説明はコメントである程度しているつもりですが、質問などあればこちらも遠慮なく聞いてください。

```python
#!/usr/bin/env python3.11
import sys
from time       import sleep
from subprocess import run, check_output, Popen, PIPE
from math       import isqrt, perm, comb
from random     import random, randint, randrange
from random     import shuffle, choice, choices, sample
from string     import ascii_lowercase
from itertools  import product, permutations, combinations, combinations_with_replacement
from itertools  import pairwise

FILE_IN  = 'stdin.txt'
FILE_OUT = 'stdout.txt'
FILE_ERR = 'stderr.txt'

def generate():
  for _ in range(20):
    # テストケース生成
    lim = 10**9
    x = randint(5, lim-5)
    y = randint(5, lim-5)
    dx, dy = choice([(0,+1), (0,-1), (+1,0), (-1,0)])
    # ファイルに書き込み
    with open(FILE_IN, 'w') as f:
      print(x, y, dx, dy, file=f)
    verify()    # やらなくてもいい
    sleep(0.1)  # 入力データがパラパラ変化するようになって、見ていて楽しい
    yield

def verify():
  with open(FILE_IN) as f:
    pass

def simple():
  ok = 0
  ng = 0
  # ログをクリア
  with open(FILE_ERR, 'w') as _:
    pass
  for _ in generate():
    # 自分のプログラムを実行
    with open(FILE_IN) as f:
      # ファイル名は各自の環境に合わせて適当に編集
      # バイナリの場合
      me = check_output(['./a.out'], stdin=f, timeout=2, text=True)
      # Python の場合
      me = check_output(['python3.11', 'main.py'], stdin=f, timeout=2, text=True)
    # ACプログラムを実行
    with open(FILE_IN) as f:
      # バイナリの場合
      ac = check_output(['./b.out'], stdin=f, timeout=10, text=True)
      # Python の場合
      ac = check_output(['python3.11', 'naive.py'], stdin=f, timeout=10, text=True)
    # 出力を比較
    # 誤答の場合、入力データ、自分の出力、AC出力をログに追記
    if me == ac:
      ok += 1
    else:
      ng += 1
      with open(FILE_IN) as f, open(FILE_ERR, 'a') as e:
        print('===', file=e)
        print(f.read().rstrip(), file=e)
        print('me:', file=e)
        print(me.rstrip(), file=e)
        print('ac:', file=e)
        print(ac.rstrip(), file=e)
        e.flush()
  if ng == 0:
    print('AC')
  else:
    print(f'{ok=} {ng=}')

def special():
  ok = 0
  ng = 0
  # ログをクリア
  with open(FILE_ERR, 'w') as _:
    pass
  for _ in generate():
    # 自分のプログラムを実行
    with open(FILE_IN) as f, open(FILE_OUT, 'w') as g:
      # バイナリの場合
      # run(['./a.out'], stdin=f, stdout=g, timeout=2, text=True)
      # Python の場合
      run(['python3.11', 'main.py'], stdin=f, stdout=g, timeout=2, text=True)
    # ジャッジ処理を実行
    res = judge()
    # 正答なら judge は空文字列を返す
    # 非空な文字列が返ってきた場合、それを誤答理由として、誤答理由、入力データ、自分の出力をログに追記
    if res:
      ng += 1
      with open(FILE_IN) as f, open(FILE_OUT) as g, open(FILE_ERR, 'a') as e:
        print('===', file=e)
        print(res, file=e)
        print('input:', file=e)
        print(f.read().rstrip(), file=e)
        print('output:', file=e)
        print(g.read().rstrip(), file=e)
        e.flush()
    else:
      ok += 1
  if ng == 0:
    print('AC')
  else:
    print(f'{ok=} {ng=}')

def judge():
  with open(FILE_IN) as f, open(FILE_OUT) as g:
    # judge の実装例
    # 10% の確率で WA とする
    if randint(0, 9) == 0:
      return 'Hard Luck'
  return ''

def interactive():
  ok = 0
  ng = 0
  # ログをクリア
  with open(FILE_ERR, 'w') as _:
    pass
  # 例題 東京通信大学プログラミングコンテスト001 L
  # https://onlinejudge.u-aizu.ac.jp/beta/room.html#TOUPC001/problems/L
  for _ in generate():
    verdict = 'WA'
    history = []
    # テストケース (ジャッジ側が最初に持つ秘密のデータ) を読む
    with open(FILE_IN) as f:
      x, y, dx, dy = map(int, f.readline().split())
    # プログラムを起動
    with Popen(['python3.11', 'main.py'], stdin=PIPE, stdout=PIPE, stderr=PIPE, text=True) as proc:
      history.append(f'[SECRET] {x=} {y=} {dx=} {dy=}')
      for _ in range(5):
        x += dx
        y += dy
        i, j = map(int, proc.stdout.readline().split())
        d = max(abs(x-i), abs(y-j))
        print(d, file=proc.stdin, flush=True)
        history.append(f'[SECRET] {x=} {y=}')
        history.append(f'>>> {i} {j}')
        history.append(f'<<< {d}')
        if d == 0:  # adaptive を実現したいならジャッジをもっとがんばる
          sleep(1)
          proc.kill()
          if proc.returncode == 0:
            verdict = 'AC'
            break
          err = proc.stderr.read().rstrip()
          if err:
            verdict = 'RE\n' + err
          else:
            verdict = 'TLE'
          break
      # 誤答の場合、やりとりをログに追記
      if verdict == 'AC':
        ok += 1
      else:
        ng += 1
        with open(FILE_ERR, 'a') as e:
          print('===', file=e)
          print(verdict, file=e)
          print(*history, sep='\n', file=e)
          e.flush()
  if ng == 0:
    print('AC')
  else:
    print(f'{ok=} {ng=}')

if __name__ == '__main__':
  # simple, special, interactive のどれかに適宜書き換え
  interactive()
```
